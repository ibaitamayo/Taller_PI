---
title: "Día 4: Pregunta de investigación + Matching (finalfit + dplyr)"
author: "Curso R para economistas de la salud"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    highlight: tango
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    latex_engine: xelatex
---

> Dataset Kaggle: **Diabetes 130-US hospitals (1999–2008)** → `diabetic_data.csv`.  
> Restricción de nombres: usar solo `chartr()`, `stringr::str_trim()`, `stringr::str_squish()`.

## 0. Preflight

```{r preflight, echo=TRUE, message=TRUE}
req <- c("dplyr","finalfit","stringr","broom")
miss <- req[!sapply(req, requireNamespace, quietly=TRUE)]
if(length(miss)){
  stop("Faltan paquetes requeridos: ", paste(miss, collapse=", "))
}
if(!file.exists("diabetic_data.csv")){
  stop("No se encuentra 'diabetic_data.csv'. Descárgalo de Kaggle y colócalo junto a este Rmd.")
}
```

## 1. Guía por objetivos y pseudocódigo

**Pregunta tipo:**  
1) ¿Qué variables se relacionan con la **presencia de complicaciones**?  
2) Genera un **informe científico** con asociaciones univariantes y multivariantes.  
3) Propón **recomendaciones** a gestores.

**Pasos y pseudocódigo (no ejecutar tal cual):**

1) **Complicaciones (dicotómica)**  
`mutate(complication_bin = if_else(readmitted == "<30", 1L, 0L))`

2) **Dependiente**  
`y <- "complication_bin"`

3) **Explicativas y tipos**  
`names(df) <- chartr(' /()-%','_____', str_squish(str_trim(names(df))))`  
`mutate(age_mid = mapear_intervalo(age), across(nums, as.numeric))`

4) **Tabla univariante con totales (chi-cuadrado, t/Wilcoxon)**  
`summary_factorlist(dependent = y, explanatory = c(...), column = TRUE, p = TRUE, na_include = TRUE)`

5) **Selección p<0.05**  
`sig <- tab1 |> filter(!is.na(p) & p < 0.05) |> pull(label)`

6) **Modelo completo (logística)**  
`mod_full <- glm(as.formula(paste(y, "~", paste(sig, collapse=" + "))), family=binomial, data=df)`

7) **Backward (AIC)**  
`mod_back <- MASS::stepAIC(mod_full, direction="backward")`

8) **OR e IC95% + informe**  
`broom::tidy(mod_back, conf.int=TRUE, exponentiate=TRUE) |> filter(term!='(Intercept)')`

## 2. Árbol de decisión

```{r arbol, echo=FALSE, out.width='100%'}
knitr::include_graphics("arbol_decision_dia4.png")
```

## 3. Tabla de funciones clave

| Librería | Función | Uso |
|---|---|---|
| dplyr | `mutate`, `if_else`, `select`, `filter`, `across`, `case_when` | Derivar variables y seleccionar |
| finalfit | `summary_factorlist` | Tabla 1 con totales y p-values |
| stats | `chisq.test`, `t.test`, `wilcox.test` | Pruebas univariantes |
| stats | `glm(family=binomial)` | Logística binaria |
| MASS | `stepAIC` | Backward por AIC |
| broom | `tidy` | Coeficientes con IC95% |

---

## 4. Matching y equilibrio — **código completo** (sin MatchIt)

```{r matching, message=TRUE, warning=FALSE}
library(dplyr); library(stringr)

# 4.1 Carga y limpieza mínima
df0 <- read.csv("diabetic_data.csv", stringsAsFactors = FALSE)
names(df0) <- chartr(' /()-%','_____', str_squish(str_trim(names(df0))))
df <- df0 %>%
  mutate(
    complication_bin = if_else(readmitted == "<30", 1L, 0L),
    treated = if_else(diabetesMed == "Yes", 1L, 0L)
  )

# Edad a punto medio del intervalo
map_age <- c("[0-10)"=5,"[10-20)"=15,"[20-30)"=25,"[30-40)"=35,"[40-50)"=45,
             "[50-60)"=55,"[60-70)"=65,"[70-80)"=75,"[80-90)"=85,"[90-100)"=95)
df <- df %>% mutate(age_mid = unname(map_age[age]))

# Convertir a numéricas
numv <- c("time_in_hospital","num_lab_procedures","num_medications","number_diagnoses")
df <- df %>% mutate(across(all_of(intersect(numv, names(df))), ~suppressWarnings(as.numeric(.))))

dat <- df %>%
  select(complication_bin, treated, age_mid, gender, race,
         time_in_hospital, num_lab_procedures, num_medications, number_diagnoses) %>%
  tidyr::drop_na()

# 4.2 Propensity score con glm
covs <- c("age_mid","gender","race","time_in_hospital","num_lab_procedures","num_medications","number_diagnoses")
form_ps <- as.formula(paste("treated ~", paste(covs, collapse=" + ")))
ps_mod <- glm(form_ps, data = dat, family = binomial())
ps <- as.numeric(fitted(ps_mod))

# 4.3 Matching NN sin reemplazo (1:1 y 1:2)
nn_match <- function(ps, treat, k = 1){
  T_idx <- which(treat == 1); C_idx <- which(treat == 0)
  ps_T <- ps[T_idx]; ps_C <- ps[C_idx]
  used_C <- rep(FALSE, length(C_idx))
  keep_T <- integer(0); keep_C <- integer(0)
  for(i in seq_along(T_idx)){
    d <- abs(ps_C - ps_T[i]); d[used_C] <- Inf
    ord <- order(d, na.last = NA)
    take <- head(ord[is.finite(d[ord])], k)
    if(length(take) > 0){
      keep_T <- c(keep_T, rep(T_idx[i], length(take)))
      keep_C <- c(keep_C, C_idx[take])
      used_C[take] <- TRUE
    }
  }
  list(T = keep_T, C = keep_C)
}

set.seed(1); m11 <- nn_match(ps, dat$treated, k = 1)
d11 <- bind_rows(dat[m11$T, ], dat[m11$C, ])

set.seed(2); m12 <- nn_match(ps, dat$treated, k = 2)
d12 <- bind_rows(dat[m12$T, ], dat[m12$C, ])

# 4.4 Balance por SMD
smd_vec <- function(x, g){
  g <- as.integer(g)
  if(is.numeric(x)){
    (mean(x[g==1]) - mean(x[g==0])) / sqrt((var(x[g==1]) + var(x[g==0]))/2)
  } else {
    lv <- unique(x)
    smds <- sapply(lv, function(L){
      p1 <- mean(x[g==1]==L); p0 <- mean(x[g==0]==L); p <- (p1+p0)/2
      (p1 - p0) / sqrt(p*(1-p))
    })
    max(suppressWarnings(abs(smds)), na.rm = TRUE)
  }
}
balance_tbl <- function(data){
  tibble::tibble(variable = covs) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(SMD = abs(smd_vec(data[[variable]], data$treated))) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(dplyr::desc(SMD))
}

bal_pre  <- balance_tbl(dat)
bal_11   <- balance_tbl(d11)
bal_12   <- balance_tbl(d12)

# 4.5 Tasas de complicaciones pre y post
rates <- dplyr::bind_rows(
  tibble::tibble(context="Pre",      group=c("Control","Treated"),
                 rate = with(dat, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to1",group=c("Control","Treated"),
                 rate = with(d11, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to2",group=c("Control","Treated"),
                 rate = with(d12, tapply(complication_bin, treated, mean)) %>% as.numeric())
)

print(bal_pre); print(bal_11); print(bal_12); print(rates)

# 4.6 Gráficos base R del equilibrio
op <- par(mfrow=c(1,3), mar=c(5,10,3,2))
barplot(rev(bal_pre$SMD), horiz=TRUE, las=1, names.arg = rev(bal_pre$variable),
        main="SMD Pre", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
barplot(rev(bal_11$SMD), horiz=TRUE, las=1, names.arg = rev(bal_11$variable),
        main="SMD Post 1:1", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
barplot(rev(bal_12$SMD), horiz=TRUE, las=1, names.arg = rev(bal_12$variable),
        main="SMD Post 1:2", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
par(op)
```

## 5. Interpretación esperada
- **Equilibrio**: SMD < 0.1 en la mayoría de covariables tras matching.  
- **Efecto**: la diferencia en tasas de `complication_bin` entre grupos debe **cambiar** respecto al pre-matching; explica el sentido del cambio y sus implicaciones para gestión.
