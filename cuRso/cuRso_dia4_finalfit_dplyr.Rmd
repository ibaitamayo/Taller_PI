---
title: "Día 4: Pregunta de investigación + Matching"
author: "Curso R para economistas de la salud"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    highlight: tango
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    latex_engine: xelatex
---

> Dataset Kaggle: **Diabetes 130-US hospitals (1999–2008)** → `diabetic_data.csv`.
>
> Descargar desde <https://github.com/ibaitamayo/Taller_PI/blob/main/cuRso/data/diabetic_data.csv>
>
> y guardar en la carpeta datos y cargar los datos en el entorno.
>
> Carga las librerías necesarias para las funciones (mirar la tabla de ayuda)

## 1. Guía por objetivos y pseudocódigo

**Pregunta tipo:**\
1) ¿Qué variables se relacionan con la **presencia de complicaciones**?\
2) Genera un **informe científico** con asociaciones univariantes y multivariantes.\
3) Propón **recomendaciones** a gestores.

## 2. Árbol de decisión

{r arbol, echo=FALSE, out.width='100%'} knitr::include_graphics("arbol_decision_dia4.png")

## ![](arbol_decision_dia4.png)

## 3. Tabla de funciones clave

| Librería | Función                                                        | Uso                             |
|------------------------|------------------------|------------------------|
| dplyr    | `mutate`, `if_else`, `select`, `filter`, `across`, `case_when` | Derivar variables y seleccionar |
| finalfit | `summary_factorlist`                                           | Tabla 1 con totales y p-values  |
| stats    | `chisq.test`, `t.test`, `wilcox.test`                          | Pruebas univariantes            |
| stats    | `glm(family=binomial)`                                         | Logística binaria               |
| MASS     | `stepAIC`                                                      | Backward por AIC                |
| broom    | `tidy`                                                         | Coeficientes con IC95%          |

------------------------------------------------------------------------

## 

**Pasos y pseudocódigo (no ejecutar tal cual):**

Para generar una sección en la que se pueda ejecutar código pulsa simultáneamente:

**control + alt + i**

1.  Crear variable dicotómica (binaria) “complicaciones” buscando en la variable `readmitted` aquellos pacientes que reingresan antes de 30 días

·        Objetivo: definir 0/1.

·        Pseudocódigo: \
`mutate(complication_bin = if_else(readmitted == "<30", 1, 0))`

¿Qué indica esta variable?

2.  **Explicativas y tipos**

            Objetivo: elegir clínicas, demográficas y económicas plausibles; fijar tipos.

    ·        Sugerencia: age (como punto medio), gender, race, time_in_hospital, num_lab_procedures, num_medications, number_diagnoses, insulin, change, payer_code.

    ·        Pseudocódigo:

    o   limpiar nombres: names(df) \<- chartr(' /()-%','\_\_\_\_\_', str_squish(str_trim(names(df))))

    o   age_mid \<- mapear_intervalo_edad_a_punto_medio(age)

    o   convertir numéricas: as.numeric(...)\
    `names(df) <- chartr(" /-","___", str_squish(str_trim(names(df))))`\
    `mutate(age_mid = mapear_intervalo(age), across(nums, as.numeric))`

3.  **Tabla univariante con totales (chi-cuadrado, t/Wilcoxon)**

    ·        Objetivo: relaciones y p-values.

    ·        Test: **chi-cuadrado** para categóricas; **t** si normal o **Wilcoxon** si no normal para continuas.

    ·        Pseudocódigo:

    o   categórica vs y: chisq.test(table(y, x_cat))

    o   continua vs y: t.test(x_num \~ y) y wilcox.test(x_num \~ y)\
    `summary_factorlist(dependent = y, explanatory = c(...), column = TRUE, p = TRUE, na_include = TRUE)`

4.  **Selección p\<0.05**

    ·        Objetivo: marcar p\<0.05.

    ·        Pseudocódigo: sig \<- vars[p \< 0.05], se puede hacer a mano\
    `sig <- tab1 |> filter(!is.na(p) & p < 0.05) |> pull(label)`

5.  **Modelo completo (logística)**

    ·        Objetivo: logística con todas las significativas y clínicamente relevantes (separadas por **+**).

    x ej: variable dependiente \~ variable explicativa 1+ variable explicativa 2 + variable explicativa...

    ·        Pseudocódigo: m_full \<- glm(y \~ sig, family=binomial)\
    `mod_full <- glm(as.formula(paste(y, "~", paste(sig, collapse=" + "))), family=binomial, data=df)`

6.  **Backward (AIC)**

    ·        Objetivo: Modelo mas simple pero que explora relaciones independientes. Se puede hacer a mano. Eliminar las que no son significativas del modelo completo. **Una a una hasta quedarse con variables que son todas significativas.**

    ·        (si se quiere con código ...hacer algo del estilo : m_back \<- step(m_full, direction="backward")\
    `mod_back <- MASS::stepAIC(mod_full, direction="backward")`

7.  **OR e IC95% + informe**

            Objetivo: OR, IC95%, p.

    ·        Pseudocódigo: OR \<- exp(coef(m_back)); IC \<- exp(confint(m_back))

    ·        Informe IMRyD: métodos, resultados (Tabla 1 + tabla del modelo), discusión, limitaciones, recomendaciones.

    \
    `broom::tidy(mod_back, conf.int=TRUE, exponentiate=TRUE) |> filter(term!='(Intercept)')`

## 4. Matching y equilibrio — **código completo** (sin MatchIt)

```{r matching, message=TRUE, warning=FALSE}
library(dplyr); library(stringr)

# 4.1 Carga y limpieza mínima
df0 <- read.csv("datos/diabetic_data.csv", stringsAsFactors = FALSE)
names(df0) <- chartr(" /-","___", str_squish(str_trim(names(df0))))
df <- df0 %>%
  mutate(
    complication_bin = if_else(readmitted == "<30", 1, 0),
    treated = if_else(diabetesMed == "Yes", 1, 0)
  )

# Edad a punto medio del intervalo
map_age <- c("[0-10)"=5,"[10-20)"=15,"[20-30)"=25,"[30-40)"=35,"[40-50)"=45,
             "[50-60)"=55,"[60-70)"=65,"[70-80)"=75,"[80-90)"=85,"[90-100)"=95)
df <- df %>% mutate(age_mid = unname(map_age[age]))

# Convertir a numéricas
numv <- c("time_in_hospital","num_lab_procedures","num_medications","number_diagnoses")
df <- df %>% mutate(across(all_of(intersect(numv, names(df))), ~suppressWarnings(as.numeric(.))))

dat <- df %>%
  select(complication_bin, treated, age_mid, gender, race,
         time_in_hospital, num_lab_procedures, num_medications, number_diagnoses) %>%
  tidyr::drop_na()

# 4.2 Propensity score con glm
covs <- c("age_mid","gender","race","time_in_hospital","num_lab_procedures","num_medications","number_diagnoses")
form_ps <- as.formula(paste("treated ~", paste(covs, collapse=" + ")))
ps_mod <- glm(form_ps, data = dat, family = binomial())
ps <- as.numeric(fitted(ps_mod))

# 4.3 Matching NN sin reemplazo (1:1 y 1:2)
nn_match <- function(ps, treat, k = 1){
  T_idx <- which(treat == 1); C_idx <- which(treat == 0)
  ps_T <- ps[T_idx]; ps_C <- ps[C_idx]
  used_C <- rep(FALSE, length(C_idx))
  keep_T <- integer(0); keep_C <- integer(0)
  for(i in seq_along(T_idx)){
    d <- abs(ps_C - ps_T[i]); d[used_C] <- Inf
    ord <- order(d, na.last = NA)
    take <- head(ord[is.finite(d[ord])], k)
    if(length(take) > 0){
      keep_T <- c(keep_T, rep(T_idx[i], length(take)))
      keep_C <- c(keep_C, C_idx[take])
      used_C[take] <- TRUE
    }
  }
  list(T = keep_T, C = keep_C)
}

set.seed(1); m11 <- nn_match(ps, dat$treated, k = 1)
d11 <- bind_rows(dat[m11$T, ], dat[m11$C, ])

set.seed(2); m12 <- nn_match(ps, dat$treated, k = 2)
d12 <- bind_rows(dat[m12$T, ], dat[m12$C, ])

# 4.4 Balance por SMD
smd_vec <- function(x, g){
  g <- as.integer(g)
  if(is.numeric(x)){
    (mean(x[g==1]) - mean(x[g==0])) / sqrt((var(x[g==1]) + var(x[g==0]))/2)
  } else {
    lv <- unique(x)
    smds <- sapply(lv, function(L){
      p1 <- mean(x[g==1]==L); p0 <- mean(x[g==0]==L); p <- (p1+p0)/2
      (p1 - p0) / sqrt(p*(1-p))
    })
    max(suppressWarnings(abs(smds)), na.rm = TRUE)
  }
}
balance_tbl <- function(data){
  tibble::tibble(variable = covs) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(SMD = abs(smd_vec(data[[variable]], data$treated))) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(dplyr::desc(SMD))
}

bal_pre  <- balance_tbl(dat)
bal_11   <- balance_tbl(d11)
bal_12   <- balance_tbl(d12)

# 4.5 Tasas de complicaciones pre y post
rates <- dplyr::bind_rows(
  tibble::tibble(context="Pre",      group=c("Control","Treated"),
                 rate = with(dat, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to1",group=c("Control","Treated"),
                 rate = with(d11, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to2",group=c("Control","Treated"),
                 rate = with(d12, tapply(complication_bin, treated, mean)) %>% as.numeric())
)

print(bal_pre); print(bal_11); print(bal_12); print(rates)

# 4.6 Gráficos base R del equilibrio
op <- par(mfrow=c(1,3), mar=c(5,10,3,2))
barplot(rev(bal_pre$SMD), horiz=TRUE, las=1, names.arg = rev(bal_pre$variable),
        main="SMD Pre", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
barplot(rev(bal_11$SMD), horiz=TRUE, las=1, names.arg = rev(bal_11$variable),
        main="SMD Post 1:1", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
barplot(rev(bal_12$SMD), horiz=TRUE, las=1, names.arg = rev(bal_12$variable),
        main="SMD Post 1:2", xlab="|SMD|"); abline(v=0.1, col="red", lty=2)
par(op)
```



## 5. Matching con MatchIt y visualización del equilibrio con cobalt — **código completo**

```{r matching, message=TRUE, warning=FALSE}
library(dplyr); library(stringr); library(readr); library(tidyr)
library(MatchIt); library(cobalt); library(janitor)


# 5.1 Carga y limpieza mínima
df0 <- read.csv("datos/diabetic_data.csv", stringsAsFactors = FALSE,na.strings = "?")
names(df0) <- chartr(" /-","___", str_squish(str_trim(names(df0))))
# Edad a punto medio del intervalo
map_age <- c("[[0-10)"=5,"[10-20)"=15,"[20-30)"=25,"[30-40)"=35,"[40-50)"=45,
             "[50-60)"=55,"[60-70)"=65,"[70-80)"=75,"[80-90)"=85,"[90-100)"=95)
map_weight <- c("[0-25)"=12.5,"[100-125)"=112.5,"[125-150)"= 137.5,"[150-175)"=162.5,"[175-200)"=187.5,
             "[25-50)"=37.5,"[50-75)"=62.5,"[75-100)"=87.5,">200"=220)
df0 <- df0 %>% mutate(age_mid = unname(map_age[age]),weight_mid = unname(map_weight[weight]))



df <- df0 %>%
  mutate(
    complication_bin = if_else(readmitted == "<30", 1, 0),
    treated = if_else(diabetesMed == "Yes", 1, 0)
  )

# df %>% mutate(quitar=ifelse(diabetesMed=="Yes"&age_mid>=85,1,0)) %>% filter(quitar==0)->df


# Convertir a numéricas
numv <- c("time_in_hospital","num_lab_procedures","num_medications","number_diagnoses")
df <- df %>% mutate(across(all_of(intersect(numv, names(df))), ~suppressWarnings(as.numeric(.))))

dat <- df %>%
  drop_na()

# 5.2 Propensity score y matching NN 1:1 y 1:2

set.seed(1)
m1 <- matchit(treated ~  age_mid+weight_mid+ num_medications+num_lab_procedures+time_in_hospital+gender, data = dat, method = "nearest", ratio = 1)
d1 <- match.data(m1)

set.seed(2)
m2 <- matchit(treated ~ age_mid+ num_medications+num_lab_procedures+time_in_hospital, data = dat, method = "nearest", ratio = 2)
d2 <- match.data(m2)

# 5.3 Diagnóstico de equilibrio (SMD) y figuras
love.plot(m1, binary = "std", abs = TRUE, thresholds = c(m = .1), var.order="unadjusted",
          colors = c("grey", "black"), shapes = c(16, 17), title = "Equilibrio SMD - Matching 1:1")
love.plot(m2, binary = "std", abs = TRUE, thresholds = c(m = .1), var.order="unadjusted",
          colors = c("grey", "black"), shapes = c(16, 17), title = "Equilibrio SMD - Matching 1:2")

# Tabla de balance resumida
bal_11 <- bal.tab(m1, un = TRUE, m.threshold = 0.1)
bal_12 <- bal.tab(m2, un = TRUE, m.threshold = 0.1)
print(bal_11); print(bal_12)

# 5.4 Tasas de complicaciones pre y post
rates <- dplyr::bind_rows(
  tibble::tibble(context="Pre",      group=c("Control","Treated"),
                 rate = with(dat, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to1",group=c("Control","Treated"),
                 rate = with(d1, tapply(complication_bin, treated, mean)) %>% as.numeric()),
  tibble::tibble(context="Post_1to2",group=c("Control","Treated"),
                 rate = with(d2, tapply(complication_bin, treated, mean)) %>% as.numeric())
)
rates
```


